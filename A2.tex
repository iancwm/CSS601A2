\documentclass[12pt, letterpaper]{article}

\usepackage{amsmath}
\usepackage[a4paper, portrait, margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{tikz}
\usepackage{listings}
\usepackage{multirow}
\usepackage{bookmark}

\renewcommand{\thesection}{Question \arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}\alph{subsection})}
\renewcommand{\thesubsubsection}{\roman{subsubsection})}
\renewcommand{\thefigure}{\arabic{figure}}

\lstset{
basicstyle=\small\ttfamily,
columns=flexible,
breaklines=true
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}


\title{CSS601 Introduction to Artificial Intelligence - Assignment 2}
\author{Ian Chong Wei Ming\\
\href{mailto:ian.chong.2020@mitb.smu.edu.sg}{ian.chong.2020@mitb.smu.edu.sg}\\
+65-9680-8118}
\date{\today}

\begin{document}

\maketitle
\section{Heuristic Search}

\begin{tikzpicture}[node distance=3.5cm]
        
    \node[circle,draw] (S) {$S$};
    \node[circle,draw, below of=S] (B) {$B$};
    \node[circle,draw, left of=B] (A) {$A$};
    \node[circle,draw, right of=B] (C) {$C$};
    \node[circle,draw, below of=B] (D) {$D$};
    \node[circle,draw, below of=A] (E) {$E$};
    \node[circle,draw, below of=C] (F) {$F$};
    \node[circle,draw, below of=D] (H) {$H$};
    \node[circle,draw, below of=H] (G) {$G$};

    \path [->,draw] 
    (S) -- (B)
    (S) -- (A)
    (S) -- (C)
    (A) -- (B)
    (A) -- (E)
    (A) -- (H)
    (B) -- (C)
    (B) -- (D)
    (C) -- (D)
    (C) -- (F)
    (E) -- (H)
    (D) -- (H)
    (F) -- (H)
    (H) -- (G);

    \path[->,draw]
    (S) edge node[right, near end] {(3,\textcolor{red}{11})} (B)
    (S) edge node[left, near end] {(7,\textcolor{red}{13})} (A)
    (S) edge node[right, near end] {(8,\textcolor{red}{8})} (C)
    (A) edge node[above, near end] {(2,\textcolor{red}{11})} (B)
    (A) edge node[left, near end] {(6,\textcolor{red}{7})} (E)
    (A) edge node[right] {(10,\textcolor{red}{2})} (H)
    (B) edge node[above] {(4,\textcolor{red}{8})} (C)
    (B) edge node[left, near end] {(7,\textcolor{red}{5})} (D)
    (C) edge node[right, near end] {(1,\textcolor{red}{5})} (D)
    (C) edge node[right, near end] {(6,\textcolor{red}{7})} (F)
    (E) edge node[left, near end] {(5,\textcolor{red}{2})} (H)
    (D) edge node[right, near end] {(4,\textcolor{red}{2})} (H)
    (F) edge node[right, near end] {(4,\textcolor{red}{2})} (H)
    (H) edge node[right, near end] {3} (G);
\end{tikzpicture}

For the above graph (heuristic values are provided in red color and actual costs are in black
color), please provide answers to the following answers. Also note that S is start state and G
is goal state.

\subsubsection{Is the heuristic admissible?}

\begin{center}
    \begin{tabular}{|c|c|c|} 
    \hline
    Node $n$ & Minimum cost to reach $G$ from $n$ & $h(n)$ \\ 
    \hline
    S & bla & bla \\
    \hline
    A & bla & bla \\
    \hline
    B & bla & bla \\
    \hline
    C & bla & bla \\
    \hline
    E & bla & bla \\
    \hline
    D & bla & bla \\
    \hline
    F & bla & bla \\
    \hline
    H & bla & bla \\
    \hline
    \end{tabular}
\end{center}

\subsubsection{Is the heuristic consistent? Provide justification}
Answer goes here.

\subsubsection{DFS, BFS, Best First Search and A* Search}
Provide the search steps (as discussed in class) with DFS, BFS (with and without priority
queue), Best First Search and A* search. Specify for each algorithm if the open list is
queue, stack, or priority queue. Feel free to add rows/columns, or other details in the
table below. Open list contains nodes that are to be explored, and “Nodes to add” are
the successors of the node that is recently popped.


\begin{center}
    \begin{tabular}{|c|c|c|c|} 
    \hline
    Step No. & Open List & POP & Nodes to add \\ 
    \hline
    1 & S & bla & bla \\
    \hline
    2 & S & bla & bla \\
    \hline
    3 & S & bla & bla \\
    \hline
    \end{tabular}
\end{center}

\section{Build an automated car in a simulator}

The goal of this assignment is to guide your car to move in a multi-lane straight road (represented using a rectangular grid) simulator (details explained later). 

In addition to your car, there are other cars also moving along the road. You need to design an algorithm which can take your car from its start position to the end of the road as soon as possible while avoiding other cars. 

Other cars are moving randomly. At any step, your car can view up to 4 cells in front, left and right, i.e., it will not be able to look at the other cars which are beyond its visibility range of 4 cells. (This visibility range of 4 is configurable and your algorithm should work irrespective of visibility range).

We describe the state, operators and goal state for this problem below.

\textbf{State}: State of the car is its location, i.e., the grid cell it is currently present in. 

\textbf{Operators/Actions}: Following are the available operators or actions for the car:

\begin{itemize}
    \item \textbf{Forward} – Moves the car one step ahead in the same lane.
    \item \textbf{Forward-2$\times$} – Moves the car two steps ahead in the same lane.
    \item \textbf{Forward-3$\times$} – Moves the car three steps ahead in the same lane.
    \item \textbf{Left} – Moves the car in the left lane and one step forward.
    \item \textbf{Right} – Moves the car in the right lane and one step forward.
    \item \textbf{None} – Stays at the same place.
\end{itemize}

If the action is unsuccessful then the car will stay at the same place. Action will be unsuccessful if there is a wall or another car present in the intended direction of move. For example, a forward will be unsuccessful if there is another car present in front of your car.
As the left action moves a car to the left and one step forward, a left action taken in grid cell (5,3) will be unsuccessful if there is a car in either of (4,3) or (4,4).

\textbf{Goal State:} There is one goal state, where your car needs to reach.

\subsection{Write the function}
Write the function that will generate the \textbf{operator/action} to be taken at the current time step (based on search algorithms discussed in class), so that time taken to reach goal is as \textit{minimal} as possible. [You may refer to “\texttt{pseudo code.pdf}” for implementation details and pseudo code for $A* Search$.]
The code for the Simulator is provided in the zip file SelfDrivingCar.zip. The details about the
installation/running of simulator and code details are provided in the file SelfDrivingCar.pdf
(present in the zip file).

\subsection{Submit code in \texttt{.pdf}}

\section{Taxi Driver Markov Decision Process}
Taxi drivers in Singapore can pick up customers from any location that is not on highways. 
However, they require guidance on where to pick up customers when they do not have customers on board and there are no bookings. 
In this question, we address this guidance problem. 
There are four locations: $L1$, $L2$, $L3$ and $L4$ from where taxi drivers can pick up and drop off customers. 
At any decision epoch, the chances of the taxi driver picking up a customer from different locations are provided in \textbf{Table 1} below:

\begin{center}
    \textbf{Table 1}

    \begin{tabular}{|c|c|} 
    \hline
    Location & Chance of finding customer\\ 
    \hline
    $L1$ & 0.3 \\
    \hline
    $L2$ & 0.8 \\
    \hline
    $L3$ & 0.1 \\
    \hline
    $L4$ & 0.6 \\
    \hline
    \end{tabular}
    
\end{center}

Once the taxi driver picks up a customer, the customer determines the destination. Observed
probabilities (from past data) of a customer starting from a source location and going to a
destination location are given below:

\begin{center}
    \textbf{Table 2}

    \begin{tabular}{|c|c|} 
    \hline
    $Source \rightarrow Destination$ & Probability\\ 
    \hline
    $L1 \rightarrow L2$ & 0.4 \\
    \hline
    $L1 \rightarrow L3$ & 0.35 \\
    \hline
    $L1 \rightarrow L4$ & 0.25 \\
    \hline
    $L2 \rightarrow L1$ & 0.4 \\
    \hline
    $L2 \rightarrow L3$ & 0.6 \\
    \hline
    $L3 \rightarrow L1$ & 0.6 \\
    \hline
    $L3 \rightarrow L4$ & 0.4 \\
    \hline
    $L4 \rightarrow L1$ & 0.65 \\
    \hline
    $L4 \rightarrow L2$ & 0.35 \\
    \hline
    \end{tabular}    
\end{center}
\textit{**If a source destination pair does not appear in the above table, it indicates the fare is 0.}

Cost of travelling between locations is as follows:

\begin{center}
    \textbf{Table 3}

    \begin{tabular}{|c|c|} 
    \hline
    $Source \rightarrow Destination$ & Cost (\$)\\ 
    \hline
    $L1 \rightarrow L2$ & 1.00 \\
    \hline
    $L1 \rightarrow L3$ & 1.50 \\
    \hline
    $L1 \rightarrow L4$ & 1.25 \\
    \hline
    $L2 \rightarrow L1$ & 1.00 \\
    \hline
    $L2 \rightarrow L3$ & 0.75 \\
    \hline
    $L3 \rightarrow L1$ & 1.50 \\
    \hline
    $L3 \rightarrow L4$ & 0.80 \\
    \hline
    $L4 \rightarrow L1$ & 1.25 \\
    \hline
    $L4 \rightarrow L2$ & 1.00 \\
    \hline
    \end{tabular}
\end{center}
\textit{**If a source destination pair does not appear in the above table, it indicates the cost is infinity. If the taxi does not move (i.e., source and destination are same), then the cost is zero.}

The taxi driver can either pickup from the current location or move to another location. 
Pickup corresponds to picking up a customer (if one is found) and dropping them of at their destination. 
Pickup action succeeds with probabilities specified in \textbf{Table 1} and if the taxi picks up a customer, destination location is determined by the probabilities in \textbf{Table 2}. 
When Pickup action fails, the taxi remains in its current location. 
Move to another location is always successful and taxi moves to the desired location with probability 1.
Both pickup and move actions take one-time step each. Please provide the following: 

\subsection{MDP Model for "move and pickup customers"}

\begin{table}[]
    \begin{tabular}{|c|l|l|l|l|}
    \hline
    s (current state)        &$a$ (action) & $s'$ (new state) & $P(s'|s,a)$ & $R(s,a,s')$ \\ \hline
    \multirow{19}{*}{State1} &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \cline{2-5} 
                             &            &                &                 &                 \\ \hline
        \end{tabular}
\end{table}
\subsection{Initialize $\forall s,V^0(s)=0$ and calculate:}

\subsubsection{$\forall s,V^1(s),V^2(s),V^3(s)$}

\subsubsection{$\forall s,\pi^1(s),\pi^2(s),\pi^3(s)$}

\section{\texttt{OpenAI FrozenLake} environment}

In this question, you need to install OpenAI gym (\href{http://gym.openai.com/docs/}{http://gym.openai.com/docs/}). 
Once the gym is installed, you have to implement \textit{Q-learning} for the \texttt{FrozenLake} environment (\href{https://gym.openai.com/envs/FrozenLake-v0/}{https://gym.openai.com/envs/FrozenLake-v0/}) in python using the gym library and show the rewards obtained. 
You may use a discount factor of \texttt{0.95}. 
Please provide the following two things in your solution for this question: 

\subsection{Implement \textit{Q-learning}}
Code that implements \textit{Q-learning} for \texttt{Frozenlake} example in \texttt{gym}. 
Copy and paste the code in the solution pdf, and provide the actual code file also.

\subsection{Episode return}
For each episode, compute the total accumulated reward (also called \textit{episode return}). Plot the average return (over the last 100 episodes) while your agent is learning (x-axis will be the episode number, y-axis will be the average return over the last 100 episodes). \textbf{Make sure that you train for sufficiently many episodes so that convergence occurs}.

The goal in this question is to ensure you familiarize yourself with \texttt{OpenAI} and understand how to implement \textit{Q-learning} in \texttt{OpenAI}. 
There are many resources available online on implementing \textit{Q-learning} in \texttt{OpenAI} and the right value of learning rate for the \texttt{FrozenLake} example.
You are free to refer to them, but please write your own code. 
Tabular \textit{Q-learning} should work in this question.

\section{\texttt{200Reviews.csv} SVD}

In this question, you will employ \textit{Singular Value Decomposition} to obtain word embeddings and compare the generated word embeddings with the word embeddings generated using \texttt{word2vec}. 
The corpus (or dataset) to be considered is "\texttt{200Reviews.csv}". You need to do the following: 

\subsection{Parsing data}
Parse the reviews in "\texttt{200Reviews.csv}", i.e., divide reviews into sentences and sentences into words and remove the stop words. You can employ the "\texttt{NLP-pipeline-example.ipynb}" example we talked about in class.

\subsection{Co-occurence matrix}
Create the co-occurrence matrix for all the remaining words (after stop words are eliminated), where the window of co-occurrence is 5 on either side of the word. 

\subsection{Word embeddings}
Apply SVD and obtain word embeddings of size 100.  

Then, please generate word embeddings of size 100 using \texttt{Word2Vec.pynb} (from the NLP lecture) on the same "\texttt{200Reviews.csv}" dataset. 
Please show comparison on few examples to understand which method works better. 
Note your observations in your solution.

\end{document}
